import { Box, CircularProgress, Typography } from '@mui/material'
import { useAtom } from 'jotai'
import { isEmpty } from 'lodash'
import queryString from 'query-string'
import { useEffect, useState } from 'react'
import { isMobile } from 'react-device-detect'
import SimpleBar from 'simplebar-react'
import { notificationsAtom } from 'src/atoms/notiAtoms'
import { notiToast } from 'src/components/common/Toast'
import { ModalMui } from 'src/components/ModalMui'
import { DevelopmentNoteType } from 'src/constants/types'
import { NoteModal } from 'src/modules/dashboard/development-dashboard/component/modal/note-modal'
import { checkNotification } from 'src/service/notiService'
import { axios } from 'src/utils/axios'
import { getErrorMessage } from 'src/utils/utils'
import { ItemNotification } from './ItemNotification'

// Generated by https://quicktype.io

export const NotificationsList = () => {
  const [isOpenModalDevelopmentNote, setIsOpenModalDevelopmentNote] =
    useState<boolean>(false)

  const [dataDevelopmentNote, setDataDevelopmentNote] =
    useState<DevelopmentNoteType>(null)
  const { loading, notifications, setNotifications, unreadCount } =
    useNotiList()

  const handleRemoveOne = async (notificationId) => {
    try {
      await axios.delete(
        `/notifications/delete-notification?notificationId=${notificationId}`
      )
      setNotifications((prevState) =>
        prevState.filter((notification) => {
          return notification.notificationId !== notificationId
        })
      )
    } catch (error) {
      notiToast({
        message: getErrorMessage(error),
        type: 'error',
      })
    }
  }

  const handleClickOne = async (notificationId) => {
    try {
      await checkNotification(notificationId)
      setNotifications((prevState) =>
        prevState.map((notification) => {
          if (notification.notificationId === notificationId) {
            return Object.assign({}, notification, {
              notificationStatus: true,
            })
          } else {
            return notification
          }
        })
      )
    } catch (error) {
      notiToast({
        message: getErrorMessage(error),
        type: 'error',
      })
    }
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center p-4 ">
        <CircularProgress />
      </div>
    )
  }

  if (isEmpty(notifications)) {
    return (
      <Box sx={{ p: 2 }}>
        <Typography variant="subtitle2">There are no notifications</Typography>
      </Box>
    )
  }
  return (
    <>
      <ModalMui
        sx={{
          padding: 0,
          top: '50%',
          width: isMobile ? '100%' : 700,
          overflow: 'auto',
        }}
        isOpen={isOpenModalDevelopmentNote}
        onClose={setIsOpenModalDevelopmentNote}
      >
        <SimpleBar style={{ maxHeight: 850 }}>
          <NoteModal
            setIsOpenModal={setIsOpenModalDevelopmentNote}
            item={dataDevelopmentNote}
            update
          />
        </SimpleBar>
      </ModalMui>
      {notifications.map((notification) => {
        return (
          <ItemNotification
            setDataDevelopmentNote={setDataDevelopmentNote}
            setIsOpenModalDevelopmentNote={setIsOpenModalDevelopmentNote}
            notification={notification}
            handleClickOne={handleClickOne}
            handleRemoveOne={handleRemoveOne}
            onClose={() => {}}
          />
        )
      })}
    </>
  )
}

export const useNotiList = () => {
  // const [notifications, setNotifications] = useState<INoti[]>([])
  const [notifications, setNotifications] = useAtom(notificationsAtom)
  const [unreadCount, setUnreadCount] = useState(0)
  const [loading, setLoading] = useState(true)

  const getListNoti = async () => {
    try {
      setLoading(true)
      const params = {
        limit: 100,
        sorted: 'asc',
      }
      const { data } = await axios.get(
        `/notifications/get-list-notifications?${queryString.stringify(params)}`
      )
      setNotifications(data.data)
      setUnreadCount(data.unreadNotification)
    } catch (error) {
      notiToast({
        message: getErrorMessage(error),
        type: 'error',
      })
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    getListNoti()
  }, [])
  return {
    loading,
    notifications,
    setNotifications,
    unreadCount,
  }
}
